/*
Integer complexity is the smallest number of 1s you need to make a certain positive number, 
using only addition and multiplication. Because we typically use infix notation for math expressions, grouping with parenthesis is also allowed.

Your goal is for a given positive integer to compute its integer complexity.

Your program will be tested against inputs up to 200 000. Even relatively fast solutions may time out occasionally. 
If your solution times out and it's close to finishing, try again.

Examples:

1 -> 1    1
2 -> 2    1 + 1
3 -> 3    1 + 1 + 1
6 -> 5    (1 + 1 + 1) * (1 + 1)
8 -> 6    (1 + 1) * (1 + 1) * (1 + 1)

//--------------------------------------------------------------------

Целочисленная сложность — это наименьшее количество единиц, которое вам нужно, чтобы получить определенное положительное число, 
используя только сложение и умножение. Поскольку мы обычно используем инфиксную запись для математических выражений, группировка с помощью скобок также допускается.

Ваша цель — вычислить целочисленную сложность для данного положительного целого числа.

Ваша программа будет протестирована на входных данных до 200 000. Даже относительно быстрые решения могут иногда выходить из строя.
Если время выполнения вашего решения истекло и оно близко к завершению, попробуйте еще раз.

Примеры:

1 -> 1    1
2 -> 2    1 + 1
3 -> 3    1 + 1 + 1
6 -> 5    (1 + 1 + 1) * (1 + 1)
8 -> 6    (1 + 1) * (1 + 1) * (1 + 1)
*/

// function integerComplexity(N) {
//   if (N === 1) return 1;

//     let dp = new Array(N + 1).fill(Infinity);
//     dp[1] = 1;

//     for (let i = 2; i <= N; i++) {
//         // Проверяем, можно ли представить число i как i * 1
//         let j = Math.floor(Math.sqrt(i));
//         while (j > 1) {
//             if (i % j === 0) {
//                 dp[i] = Math.min(dp[i], dp[j] + dp[i / j]);
//                 break;
//             }
//             j--;
//         }

//         // Если не нашли, то проверяем, можно ли представить число i как сумма единиц
//         if (dp[i] === Infinity) {
//             dp[i] = 1 + dp[i - 1];
//         }
//     }

//     return dp[N];
// };

// function integerComplexity(N) {
//     // Базовый случай: сложность для 1 равна 1 (потому что это просто "1")
//     if (N === 1) {
//         return 1;
//     }

//     // Создаем массив для хранения минимальной сложности для каждого числа от 1 до N.
//     // Инициализируем все значения как Infinity, кроме dp[1].
//     let dp = new Array(N + 1).fill(Infinity);
//     dp[1] = 1; // Сложность числа 1 - это 1 единица.

//     // Итерируем от 2 до N, вычисляя сложность для каждого числа.
//     for (let i = 2; i <= N; i++) {
//         // Шаг 1: Рассматриваем случай сложения.
//         // Число 'i' может быть получено как '(i-1) + 1'.
//         // Таким образом, его сложность будет сложностью (i-1) плюс одна единица.
//         dp[i] = dp[i - 1] + 1;

//         // Шаг 2: Рассматриваем случай умножения.
//         // Итерируем по всем возможным делителям 'j' числа 'i'.
//         // Мы ищем 'j' такие, что 'i % j === 0'.
//         // Если 'j' является делителем, то 'i' можно представить как 'j * (i / j)'.
//         // Сложность в этом случае будет 'dp[j] + dp[i / j]'.
//         // Мы ищем минимальное значение среди всех таких комбинаций.
//         // Оптимизация: достаточно проверять делители до Math.sqrt(i),
//         // так как если 'j' является делителем, то 'i/j' также является делителем.
//         // Если 'j' больше Math.sqrt(i), то 'i/j' будет меньше Math.sqrt(i) и уже будет проверено.
//         for (let j = 2; j * j <= i; j++) {
//             if (i % j === 0) {
//                 // Если 'j' является делителем 'i', то 'i/j' также является целым числом.
//                 // Обновляем dp[i], если текущая комбинация умножения дает меньшую сложность.
//                 dp[i] = Math.min(dp[i], dp[j] + dp[i / j]);
//             }
//         }
//     }

//     // Возвращаем вычисленную минимальную сложность для числа N.
//     return dp[N];
// }

// /**
//  * Вычисляет целочисленную сложность для заданного положительного целого числа N.
//  * Целочисленная сложность - это наименьшее количество единиц, необходимое для получения числа N,
//  * используя только сложение и умножение, с возможностью группировки скобками.
//  *
//  * Оптимизированная версия с использованием подхода, похожего на "решето" для улучшения производительности.
//  *
//  * @param {number} N - Положительное целое число, для которого нужно вычислить сложность.
//  * @returns {number} Целочисленная сложность числа N.
//  */
// function integerComplexity(N) {
//     // Базовый случай: сложность для 1 равна 1 (потому что это просто "1")
//     if (N === 1) {
//         return 1;
//     }

//     // Создаем массив для хранения минимальной сложности для каждого числа от 1 до N.
//     // Инициализируем все значения как Infinity.
//     let dp = new Array(N + 1).fill(Infinity);
//     dp[1] = 1; // Сложность числа 1 - это 1 единица.

//     // Шаг 1: Инициализируем dp[i] для всех i, рассматривая только сложение.
//     // Это гарантирует, что у нас есть базовая стоимость для каждого числа.
//     // Например, dp[i] = dp[i-1] + 1.
//     for (let i = 2; i <= N; i++) {
//         dp[i] = dp[i - 1] + 1;
//     }

//     // Шаг 2: Оптимизируем значения dp[i], рассматривая умножение.
//     // Мы перебираем все возможные пары множителей (j, k)
//     // и обновляем сложность их произведения (j * k).
//     // Этот подход похож на "решето" и более эффективен, чем поиск делителей для каждого числа.
//     for (let j = 2; j <= N; j++) {
//         // Если сложность j все еще Infinity, это означает, что j недостижимо
//         // или еще не было вычислено, что не должно произойти с нашим порядком.
//         // Но это хорошая проверка, если логика изменится.
//         if (dp[j] === Infinity) {
//             continue;
//         }

//         // Итерируем по k, чтобы найти произведения j * k.
//         // Начинаем k с 2, так как 1 уже обработана в dp[1] и сложении.
//         // Условие j * k <= N гарантирует, что мы остаемся в пределах массива dp.
//         for (let k = 2; j * k <= N; k++) {
//             // Обновляем dp[j * k], если комбинация dp[j] + dp[k] дает меньшую сложность.
//             // Это позволяет найти минимальную сложность для j * k,
//             // используя либо сложение, либо умножение.
//             dp[j * k] = Math.min(dp[j * k], dp[j] + dp[k]);
//         }
//     }

//     // Возвращаем вычисленную минимальную сложность для числа N.
//     return dp[N];
// }


/* @param {number} N - Положительное целое число, для которого нужно вычислить сложность.
 * @returns {number} Целочисленная сложность числа N.
 */
/* function integerComplexity(N) {
    // Базовый случай: сложность для 1 равна 1 (потому что это просто "1")
    if (N === 1) {
        return 1;
    }

    // Создаем массив для хранения минимальной сложности для каждого числа от 1 до N.
    // Инициализируем все значения как Infinity.
    let dp = new Array(N + 1).fill(Infinity);
    dp[1] = 1; // Сложность числа 1 - это 1 единица.

    // Итерируем от 2 до N, вычисляя сложность для каждого числа.
    // Для каждого числа 'i' мы рассматриваем два способа его получения:
    // 1. Путем сложения: i = (i-1) + 1
    // 2. Путем умножения: i = j * k
    for (let i = 2; i <= N; i++) {
        // Шаг 1: Инициализируем dp[i] стоимостью, полученной сложением.
        // Это гарантирует, что у нас есть базовая стоимость для каждого числа.
        // dp[i-1] уже содержит минимальную сложность для (i-1).
        dp[i] = dp[i - 1] + 1;

        // Шаг 2: Пытаемся улучшить dp[i] за счет умножения.
        // Итерируем по возможным множителям 'j' от 2 до sqrt(i).
        // Если 'j' является множителем 'i', то 'k = i / j' также является множителем.
        // Поскольку j и k всегда будут меньше i (если i не равно j*j и j=1, что не наш случай),
        // значения dp[j] и dp[k] уже будут вычислены и будут содержать их минимальную сложность.
        for (let j = 2; j * j <= i; j++) {
            if (i % j === 0) {
                let k = i / j;
                // Обновляем dp[i], если комбинация dp[j] + dp[k] дает меньшую сложность.
                dp[i] = Math.min(dp[i], dp[j] + dp[k]);
            }
        }
    }

    // Возвращаем вычисленную минимальную сложность для числа N.
    return dp[N];
} */

/**
* Вычисляет целочисленную сложность для заданного положительного целого числа N.
* Целочисленная сложность - это наименьшее количество единиц, необходимое для получения числа N,
* используя только сложение и умножение, с возможностью группировки скобками.
*
* Эта версия использует оптимизированный подход динамического программирования,
* похожий на "решето", для улучшения производительности.
*
* @param {number} N - Положительное целое число, для которого нужно вычислить сложность.
* @returns {number} Целочисленная сложность числа N.
*/
/* function integerComplexity(N) {
    // Базовый случай: сложность для 1 равна 1 (потому что это просто "1")
    if (N === 1) {
        return 1;
    }

    // Создаем массив для хранения минимальной сложности для каждого числа от 1 до N.
    // Инициализируем все значения как Infinity.
    let dp = new Array(N + 1).fill(Infinity);
    dp[1] = 1; // Сложность числа 1 - это 1 единица.

    // Шаг 1: Инициализируем dp[i] для всех i, рассматривая только сложение.
    // Это гарантирует, что у нас есть базовая стоимость для каждого числа.
    // Например, dp[i] = dp[i-1] + 1.
    for (let i = 2; i <= N; i++) {
        dp[i] = dp[i - 1] + 1;
    }

    // Шаг 2: Оптимизируем значения dp[i], рассматривая умножение.
    // Мы перебираем все возможные пары множителей (j, k)
    // и обновляем сложность их произведения (j * k).
    // Этот подход более эффективен, чем поиск делителей для каждого числа,
    // так как он похож на алгоритм "решета".
    // Временная сложность этого шага составляет O(N log N).
    for (let j = 2; j <= N; j++) {
        // Пропускаем, если dp[j] еще не вычислено (хотя с нашим порядком это не должно произойти)
        if (dp[j] === Infinity) {
            continue;
        }

        // Итерируем по k, чтобы найти произведения j * k.
        // Начинаем k с 2, так как 1 уже обработана в dp[1] и сложении.
        // Условие j * k <= N гарантирует, что мы остаемся в пределах массива dp.
        for (let k = 2; j * k <= N; k++) {
            // Обновляем dp[j * k], если комбинация dp[j] + dp[k] дает меньшую сложность.
            // Значения dp[j] и dp[k] уже являются оптимальными, так как j и k меньше j*k.
            dp[j * k] = Math.min(dp[j * k], dp[j] + dp[k]);
        }
    }

    // Возвращаем вычисленную минимальную сложность для числа N.
    return dp[N];
}
 */

/**
 * Вычисляет целочисленную сложность для заданного положительного целого числа N.
 * Целочисленная сложность - это наименьшее количество единиц, необходимое для получения числа N,
 * используя только сложение и умножение, с возможностью группировки скобками.
 *
 * Эта версия использует стандартный подход динамического программирования.
 * Временная сложность: O(N * sqrt(N)).
 *
 * @param {number} N - Положительное целое число, для которого нужно вычислить сложность.
 * @returns {number} Целочисленная сложность числа N.
 */
/* function integerComplexity(N) {
    // Базовый случай: сложность для 1 равна 1 (потому что это просто "1")
    if (N === 1) {
        return 1;
    }

    // Создаем массив для хранения минимальной сложности для каждого числа от 1 до N.
    // Инициализируем все значения как Infinity.
    let dp = new Array(N + 1).fill(Infinity);
    dp[1] = 1; // Сложность числа 1 - это 1 единица.

    // Итерируем от 2 до N, вычисляя сложность для каждого числа.
    // Для каждого числа 'i' мы рассматриваем два способа его получения:
    // 1. Путем сложения: i = (i-1) + 1
    // 2. Путем умножения: i = j * k
    for (let i = 2; i <= N; i++) {
        // Шаг 1: Инициализируем dp[i] стоимостью, полученной сложением.
        // Это гарантирует, что у нас есть базовая стоимость для каждого числа.
        // dp[i-1] уже содержит минимальную сложность для (i-1).
        dp[i] = dp[i - 1] + 1;

        // Шаг 2: Пытаемся улучшить dp[i] за счет умножения.
        // Итерируем по возможным множителям 'j' от 2 до sqrt(i).
        // Если 'j' является множителем 'i', то 'k = i / j' также является множителем.
        // Поскольку j и k всегда будут меньше i, значения dp[j] и dp[k]
        // уже будут вычислены и будут содержать их минимальную сложность.
        for (let j = 2; j * j <= i; j++) {
            if (i % j === 0) {
                let k = i / j;
                // Обновляем dp[i], если комбинация dp[j] + dp[k] дает меньшую сложность.
                // Это ключевой шаг, где мы используем уже вычисленные оптимальные сложности
                // для множителей.
                dp[i] = Math.min(dp[i], dp[j] + dp[k]);
            }
        }
    }

    // Возвращаем вычисленную минимальную сложность для числа N.
    return dp[N];
} */


//     /**
//  * Вычисляет целочисленную сложность для заданного положительного целого числа N.
//  * Целочисленная сложность - это наименьшее количество единиц, необходимое для получения числа N,
//  * используя только сложение и умножение, с возможностью группировки скобками.
//  *
//  * Эта версия использует оптимизированный подход динамического программирования,
//  * похожий на "решето", для улучшения производительности.
//  * Временная сложность: O(N log N).
//  *
//  * @param {number} N - Положительное целое число, для которого нужно вычислить сложность.
//  * @returns {number} Целочисленная сложность числа N.
//  */
// function integerComplexity(N) {
//     // Базовый случай: сложность для 1 равна 1 (потому что это просто "1")
//     if (N === 1) {
//         return 1;
//     }

//     // Создаем массив для хранения минимальной сложности для каждого числа от 1 до N.
//     // Инициализируем все значения как Infinity.
//     let dp = new Array(N + 1).fill(Infinity);
//     dp[1] = 1; // Сложность числа 1 - это 1 единица.

//     // Шаг 1: Инициализируем dp[i] для всех i, рассматривая только сложение.
//     // Это гарантирует, что у нас есть базовая стоимость для каждого числа,
//     // например, dp[i] = dp[i-1] + 1.
//     // Этот цикл также устанавливает начальные значения для простых чисел.
//     for (let i = 2; i <= N; i++) {
//         dp[i] = dp[i - 1] + 1;
//     }

//     // Шаг 2: Оптимизируем значения dp[i], рассматривая умножение.
//     // Мы перебираем все числа 'i' (которые будут выступать в качестве первого множителя)
//     // и для каждого 'i' перебираем 'j' (второй множитель).
//     // Произведение 'i * j' будет числом, сложность которого мы пытаемся оптимизировать.
//     // Этот подход похож на алгоритм "решета" (Sieve of Eratosthenes).
//     // Когда мы вычисляем dp[i * j], значения dp[i] и dp[j] уже являются
//     // оптимальными, так как 'i' и 'j' меньше или равны 'i * j'
//     // и были обработаны ранее в циклах.
//     for (let i = 2; i <= N; i++) {
//         // Если сложность dp[i] все еще Infinity, это означает, что 'i' недостижимо,
//         // но с нашей инициализацией этого не должно произойти.
//         if (dp[i] === Infinity) {
//             continue;
//         }

//         // Перебираем второй множитель 'j'.
//         // Начинаем 'j' с 'i', чтобы избежать дублирования вычислений (например, 2*3 и 3*2)
//         // и гарантировать, что 'j' уже было обработано или равно 'i'.
//         for (let j = i; i * j <= N; j++) {
//             // Обновляем dp[i * j], если комбинация dp[i] + dp[j] дает меньшую сложность.
//             dp[i * j] = Math.min(dp[i * j], dp[i] + dp[j]);
//         }
//     }

//     // Возвращаем вычисленную минимальную сложность для числа N.
//     return dp[N];
// }

/*
function integerComplexity(n) {
    if (n === 1) return 1;

    const dp = new Array(n + 1);
    dp[1] = 1;

    for (let i = 2; i <= n; i++) {
        // Initialize with the worst case (sum of 1s)
        let complexity = i;

        // Check all possible sums
        for (let j = 1; j <= i / 2; j++) {
            complexity = Math.min(complexity, dp[j] + dp[i - j]);
        }

        // Check all possible products
        for (let j = 2; j * j <= i; j++) {
            if (i % j === 0) {
                complexity = Math.min(complexity, dp[j] + dp[i / j]);
            }
        }
        dp[i] = complexity;
    }

    return dp[n];
}
    */
/**
 * Вычисляет целочисленную сложность для заданного положительного целого числа N.
 * Целочисленная сложность - это наименьшее количество единиц, необходимое для получения числа N,
 * используя только сложение и умножение, с возможностью группировки скобками.
 *
 * Эта версия использует стандартный подход динамического программирования.
 * Временная сложность: O(N * sqrt(N)).
 *
 * @param {number} N - Положительное целое число, для которого нужно вычислить сложность.
 * @returns {number} Целочисленная сложность числа N.
 */
/* function integerComplexity(N) {
    // Базовый случай: сложность для 1 равна 1 (потому что это просто "1")
    if (N === 1) {
        return 1;
    }

    // Создаем массив для хранения минимальной сложности для каждого числа от 1 до N.
    // Инициализируем все значения как Infinity.
    let dp = new Array(N + 1).fill(Infinity);
    dp[1] = 1; // Сложность числа 1 - это 1 единица.

    // Итерируем от 2 до N, вычисляя сложность для каждого числа.
    // Для каждого числа 'i' мы рассматриваем два способа его получения:
    // 1. Путем сложения: i = (i-1) + 1
    // 2. Путем умножения: i = j * k
    for (let i = 2; i <= N; i++) {
        // Шаг 1: Инициализируем dp[i] стоимостью, полученной сложением.
        // Это гарантирует, что у нас есть базовая стоимость для каждого числа.
        // dp[i-1] уже содержит минимальную сложность для (i-1).
        dp[i] = dp[i - 1] + 1;

        // Шаг 2: Пытаемся улучшить dp[i] за счет умножения.
        // Итерируем по возможным множителям 'j' от 2 до sqrt(i).
        // Если 'j' является множителем 'i', то 'k = i / j' также является множителем.
        // Поскольку j и k всегда будут меньше i, значения dp[j] и dp[k]
        // уже будут вычислены и будут содержать их минимальную сложность.
        for (let j = 2; j * j <= i; j++) {
            if (i % j === 0) {
                let k = i / j;
                // Обновляем dp[i], если комбинация dp[j] + dp[k] дает меньшую сложность.
                // Это ключевой шаг, где мы используем уже вычисленные оптимальные сложности
                // для множителей.
                dp[i] = Math.min(dp[i], dp[j] + dp[k]);
            }
        }
    }

    // Возвращаем вычисленную минимальную сложность для числа N.
    return dp[N];
} */
/* 
    class MinHeap {
    constructor() {
        this.heap = [];
    }

    push(pair) {
        this.heap.push(pair);
        this._siftUp();
    }

    pop() {
        const top = this.heap[0];
        const end = this.heap.pop();
        if (this.heap.length) {
            this.heap[0] = end;
            this._siftDown();
        }
        return top;
    }

    _siftUp() {
        let idx = this.heap.length - 1;
        const el = this.heap[idx];
        while (idx > 0) {
            let parentIdx = Math.floor((idx - 1) / 2);
            if (this.heap[parentIdx][0] <= el[0]) break;
            this.heap[idx] = this.heap[parentIdx];
            idx = parentIdx;
        }
        this.heap[idx] = el;
    }

    _siftDown() {
        let idx = 0;
        const length = this.heap.length;
        const el = this.heap[0];
        while (true) {
            let left = 2 * idx + 1;
            let right = 2 * idx + 2;
            let swap = null;

            if (left < length && this.heap[left][0] < el[0]) {
                swap = left;
            }

            if (
                right < length &&
                this.heap[right][0] < (swap === null ? el[0] : this.heap[left][0])
            ) {
                swap = right;
            }

            if (swap === null) break;

            this.heap[idx] = this.heap[swap];
            idx = swap;
        }
        this.heap[idx] = el;
    }

    isEmpty() {
        return this.heap.length === 0;
    }
}


function integerComplexity(n) {
    const dp = new Uint16Array(n + 1).fill(255);
    dp[1] = 1;

    const heap = new MinHeap();
    heap.push([1, 1]); // [complexity, value]

    while (!heap.isEmpty()) {
        const [cost, val] = heap.pop();
        if (dp[val] < cost) continue;

        // addition
        for (let i = 1; val + i <= n && i <= val; i++) {
            const next = val + i;
            const nextCost = cost + dp[i];
            if (nextCost < dp[next]) {
                dp[next] = nextCost;
                heap.push([nextCost, next]);
            }
        }

        // multiplication
        for (let i = 2; val * i <= n; i++) {
            const next = val * i;
            const nextCost = cost + dp[i];
            if (nextCost < dp[next]) {
                dp[next] = nextCost;
                heap.push([nextCost, next]);
            }
        }
    }

    return dp[n];
}
 */

// class MinHeap {
//     constructor() {
//         this.heap = [];
//     }

//     push(item) {
//         this.heap.push(item);
//         let i = this.heap.length - 1;
//         while (i > 0) {
//             let p = Math.floor((i - 1) / 2);
//             if (this.heap[p][0] <= this.heap[i][0]) break;
//             [this.heap[i], this.heap[p]] = [this.heap[p], this.heap[i]];
//             i = p;
//         }
//     }

//     pop() {
//         if (this.heap.length === 1) return this.heap.pop();
//         const top = this.heap[0];
//         this.heap[0] = this.heap.pop();
//         let i = 0;
//         while (true) {
//             let l = 2 * i + 1, r = 2 * i + 2, min = i;
//             if (l < this.heap.length && this.heap[l][0] < this.heap[min][0]) min = l;
//             if (r < this.heap.length && this.heap[r][0] < this.heap[min][0]) min = r;
//             if (min === i) break;
//             [this.heap[i], this.heap[min]] = [this.heap[min], this.heap[i]];
//             i = min;
//         }
//         return top;
//     }

//     isEmpty() {
//         return this.heap.length === 0;
//     }
// }

// function integerComplexity(n) {
//     const dp = new Uint16Array(n + 1).fill(255);
//     dp[1] = 1;

//     const heap = new MinHeap();
//     heap.push([1, 1]); // [complexity, value]

//     while (!heap.isEmpty()) {
//         const [cost, val] = heap.pop();

//         if (cost > dp[val]) continue;

//         // ➕ СЛОЖЕНИЕ: только i <= 100
//         for (let i = 1; i <= 100 && val + i <= n; i++) {
//             const next = val + i;
//             const newCost = cost + dp[i];
//             if (newCost < dp[next]) {
//                 dp[next] = newCost;
//                 heap.push([newCost, next]);
//             }
//         }

//         // ✖️ УМНОЖЕНИЕ: ограничим, чтобы не взрывалось
//         for (let i = 2; i <= 1000 && val * i <= n; i++) {
//             const next = val * i;
//             const newCost = cost + dp[i];
//             if (newCost < dp[next]) {
//                 dp[next] = newCost;
//                 heap.push([newCost, next]);
//             }
//         }
//     }

//     return dp[n];
// }

// // Предрасчёт один раз:
// const MAX = 200000;
// const dp = new Uint16Array(MAX + 1);
// dp[1] = 1;

// for (let i = 2; i <= MAX; i++) {
//     dp[i] = dp[i - 1] + 1;

//     // Оптимизация через сумму
//     for (let j = 1; j <= i / 2; j++) {
//         dp[i] = Math.min(dp[i], dp[j] + dp[i - j]);
//     }

//     // Оптимизация через делители
//     for (let j = 2; j * j <= i; j++) {
//         if (i % j === 0) {
//             dp[i] = Math.min(dp[i], dp[j] + dp[i / j]);
//         }
//     }
// }

// // Мгновенный ответ:
// function integerComplexity(n) {
//     return dp[n];
// }

// // Предвычисление (один раз)
// const MAX = 200000;
// const dp = new Uint16Array(MAX + 1);
// dp[1] = 1;

// for (let i = 2; i <= MAX; i++) {
//     dp[i] = i;
//     for (let j = 1; j <= i / 2; j++) {
//         dp[i] = Math.min(dp[i], dp[j] + dp[i - j]);
//     }
//     for (let j = 2; j * j <= i; j++) {
//         if (i % j === 0) {
//             dp[i] = Math.min(dp[i], dp[j] + dp[i / j]);
//         }
//     }
// }

// // Гарантированно быстрый ответ
// function integerComplexity(n) {
//     return dp[n];
// }


// // Предрасчёт один раз ДО начала тестов
// const MAX = 200000;
// const dp = new Uint16Array(MAX + 1);
// dp[1] = 1;

// for (let i = 2; i <= MAX; i++) {
//     dp[i] = i; // worst case: all 1s
//     for (let j = 1; j <= i / 2; j++) {
//         dp[i] = Math.min(dp[i], dp[j] + dp[i - j]);
//     }
//     for (let j = 2; j * j <= i; j++) {
//         if (i % j === 0) {
//             dp[i] = Math.min(dp[i], dp[j] + dp[i / j]);
//         }
//     }
// }

// // Мгновенный доступ — только O(1)
// function integerComplexity(n) {
//     return dp[n];
// }

/**
 * Вычисляет целочисленную сложность для заданного положительного целого числа N.
 * Целочисленная сложность - это наименьшее количество единиц, необходимое для получения числа N,
 * используя только сложение и умножение, с возможностью группировки скобками.
 *
 * Эта версия использует стандартный подход динамического программирования.
 * Временная сложность: O(N * sqrt(N)).
 *
 * @param {number} N - Положительное целое число, для которого нужно вычислить сложность.
 * @returns {number} Целочисленная сложность числа N.
 *//* 
function integerComplexity(N) {
    // Базовый случай: сложность для 1 равна 1 (потому что это просто "1")
    if (N === 1) {
        return 1;
    }

    // Создаем массив для хранения минимальной сложности для каждого числа от 1 до N.
    // Инициализируем все значения как Infinity.
    let dp = new Array(N + 1).fill(Infinity);
    dp[1] = 1; // Сложность числа 1 - это 1 единица.

    // Итерируем от 2 до N, вычисляя сложность для каждого числа.
    // Для каждого числа 'i' мы рассматриваем два способа его получения:
    // 1. Путем сложения: i = (i-1) + 1
    // 2. Путем умножения: i = j * k
    for (let i = 2; i <= N; i++) {
        // Шаг 1: Инициализируем dp[i] стоимостью, полученной сложением.
        // Это гарантирует, что у нас есть базовая стоимость для каждого числа.
        // dp[i-1] уже содержит минимальную сложность для (i-1).
        dp[i] = dp[i - 1] + 1;

        // Шаг 2: Пытаемся улучшить dp[i] за счет умножения.
        // Итерируем по возможным множителям 'j' от 2 до sqrt(i).
        // Если 'j' является множителем 'i', то 'k = i / j' также является множителем.
        // Поскольку j и k всегда будут меньше i, значения dp[j] и dp[k]
        // уже будут вычислены и будут содержать их минимальную сложность.
        for (let j = 2; j * j <= i; j++) {
            if (i % j === 0) {
                let k = i / j;
                // Обновляем dp[i], если комбинация dp[j] + dp[k] дает меньшую сложность.
                // Это ключевой шаг, где мы используем уже вычисленные оптимальные сложности
                // для множителей.
                dp[i] = Math.min(dp[i], dp[j] + dp[k]);
            }
        }
    }

    // Возвращаем вычисленную минимальную сложность для числа N.
    return dp[N];
} */
//------------------ Рабочий вариант
    function integerComplexity(N) {
  const dp = new Uint16Array(N + 1);
  for (let i = 0; i <= N; i++) dp[i] = i; // Максимум — сумма единиц
  dp[1] = 1;

  for (let i = 1; i <= N; i++) {
    // через сумму с предыдущим числом
    if (i + 1 <= N && dp[i] + 1 < dp[i + 1]) {
      dp[i + 1] = dp[i] + 1;
    }

    // через произведение
    for (let j = 2; i * j <= N; j++) {
      const m = i * j;
      const cost = dp[i] + dp[j];
      if (cost < dp[m]) {
        dp[m] = cost;
      }
    }
  }

  return dp[N];
}
//--------------------------------------


/**
 * Вычисляет целочисленную сложность для заданного положительного целого числа N.
 * Целочисленная сложность - это наименьшее количество единиц, необходимое для получения числа N,
 * используя только сложение и умножение, с возможностью группировки скобками.
 *
 * Этот вариант использует оптимизированный подход динамического программирования,
 * похожий на "решето", для улучшения производительности.
 * Временная сложность: O(N log N).
 * Пространственная сложность: O(N).
 *
 * @param {number} N - Положительное целое число, для которого нужно вычислить сложность.
 * @returns {number} Целочисленная сложность числа N.
 */

/* 
function integerComplexity(N) {
    // Создаем массив для хранения минимальной сложности для каждого числа от 0 до N.
    // Используем Uint16Array для оптимизации памяти, так как максимальная сложность
    // для N=200000 не превышает 255 (максимальное значение для Uint8Array)
    // или 65535 (максимальное значение для Uint16Array).
    const dp = new Uint16Array(N + 1);

    // Инициализируем массив.
    // dp[i] = i соответствует худшему случаю, когда число i получается суммой i единиц (1+1+...+1).
    // Это служит начальной верхней границей для сложности каждого числа.
    for (let i = 0; i <= N; i++) {
        dp[i] = i;
    }

    // Базовый случай: сложность для 1 равна 1 (потому что это просто "1").
    // Это переопределяет dp[1] с 1 на 1.
    dp[1] = 1;

    // Основной цикл динамического программирования.
    // Итерируем от 1 до N. В этом цикле 'i' выступает как один из операндов
    // (либо для сложения, либо для умножения).
    for (let i = 1; i <= N; i++) {
        // --- Вариант 1: Получение числа путем сложения ---
        // Если i + 1 не превышает N, то мы можем получить i + 1
        // как (i) + 1. Сложность будет dp[i] + dp[1] (т.е. dp[i] + 1).
        // Мы обновляем dp[i + 1], если найденный путь дает меньшую сложность.
        if (i + 1 <= N) {
            // Проверяем, является ли dp[i] + 1 лучшим способом получить i+1.
            // dp[i] уже содержит минимальную сложность для 'i'.
            if (dp[i] + 1 < dp[i + 1]) {
                dp[i + 1] = dp[i] + 1;
            }
        }

        // --- Вариант 2: Получение числа путем умножения (подход "решета") ---
        // Итерируем по второму множителю 'j', начиная с 2.
        // Произведение 'm = i * j' будет числом, сложность которого мы пытаемся оптимизировать.
        // Этот подход похож на алгоритм "решета" (Sieve of Eratosthenes) для простых чисел.
        // Когда мы вычисляем dp[m], значения dp[i] и dp[j] уже являются оптимальными,
        // так как 'i' и 'j' меньше 'm' (или 'i' равно 'm' и 'j' равно 1, что не наш случай)
        // и были обработаны ранее в циклах.
        for (let j = 2; i * j <= N; j++) {
            const m = i * j; // Текущее число, которое мы пытаемся оптимизировать
            const cost = dp[i] + dp[j]; // Сложность, если m = i * j

            // Если найденная стоимость через умножение меньше текущей минимальной сложности для 'm',
            // обновляем dp[m].
            if (cost < dp[m]) {
                dp[m] = cost;
            }
        }
    }

    // Возвращаем вычисленную минимальную сложность для числа N.
    return dp[N];
} */
module.exports = integerComplexity;
