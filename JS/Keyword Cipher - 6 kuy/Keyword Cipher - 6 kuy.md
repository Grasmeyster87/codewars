<div class="markdown prose max-w-none mb-8" id="description"><p>Third day at your new cryptoanalyst job and you come across your toughest assignment yet. Your job is to implement a simple keyword cipher. A keyword cipher is a type of monoalphabetic substitution where two parameters are provided as such (string, keyword). The string is encrypted by taking the keyword, dropping any letters that appear more than once. The rest of the letters of the alphabet that aren't used are then appended to the end of the keyword.</p>
<p>For example, if your string was "hello" and your keyword was "wednesday", your encryption key would be 'wednsaybcfghijklmopqrtuvxz'.</p>
<p>To encrypt 'hello' you'd substitute as follows,</p>
<pre><code>              abcdefghijklmnopqrstuvwxyz
  hello ==&gt;   |||||||||||||||||||||||||| ==&gt; bshhk
              wednsaybcfghijklmopqrtuvxz
</code></pre>
<p>hello encrypts into bshhk with the keyword wednesday. This cipher also uses lower case letters only.</p>
<p>Good Luck.</p>
</div>

<br> <hr> <br>

<div class="markdown prose max-w-none mb-8" id="description"><p>Третий день на вашей новой работе криптоаналитика, и вы сталкиваетесь с самым сложным заданием. Ваша задача — реализовать простой шифр с ключевым словом. Шифр ​​с ключевым словом — это тип моноалфавитной подстановки, где два параметра задаются как есть (строка, ключевое слово). Строка шифруется путем взятия ключевого слова и отбрасывания всех букв, которые встречаются более одного раза. Остальные буквы алфавита, которые не используются, затем добавляются в конец ключевого слова.</p>
<p>Например, если ваша строка была "hello", а ваше ключевое слово было "wednesday", ваш ключ шифрования будет 'wednsaybcfghijklmopqrtuvxz'.</p>
<p>Чтобы зашифровать "hello", вы должны заменить следующим образом:</p>
<pre><code> abcdefghijklmnopqrstuvwxyz
hello ==&gt; ||||||||||||||||||||||||||| ==> bshhk
wednsaybcfghijklmopqrtuvxz
</code></pre>
<p>Привет, шифруется как bshhk с ключевым словом wednesday. Этот шифр также использует только строчные буквы.</p>
<p>Удачи.</p>
</div>

### Обзор реализации

Код реализует простой **keyword cipher** для строчных латинских букв. Основная идея такая: из ключевого слова формируется шифровая азбука, затем каждая буква исходной строки заменяется на соответствующую букву из этой шифровой азбуки. Входная строка приводится к нижнему регистру, пробелы и прочие символы сохраняются без изменений.

---

### Построение базовой азбуки и нормализация ключа

- **`alpha`** — строка всех букв английского алфавита в порядке от `a` до `z`.  
  Это эталонная последовательность, по которой определяется позиция каждой исходной буквы.

- **`kw`** — ключевое слово, приведённое к нижнему регистру.  
  Это нужно, чтобы шифрование было нечувствительно к регистру входных данных и ключа.

- **`used`** — `Set` для отслеживания уже добавленных букв ключа.  
  Он предотвращает повторное включение одной и той же буквы в шифровую азбуку.

- Цикл по символам `kw` добавляет в **`key`** каждую букву ключа только один раз и только если это буква из `alpha`.  
  В результате в начале шифровой азбуки оказываются уникальные буквы ключа в порядке их первого появления.

---

### Дополнение шифровой азбуки оставшимися буквами

- После обработки ключа код проходит по всем буквам `alpha` и добавляет те, которых ещё нет в `used`.  
  Это гарантирует, что итоговая **`key`** содержит ровно 26 уникальных букв и является перестановкой алфавита.

- В итоге **`key`** — строка длиной 26, где позиция символа соответствует букве исходного алфавита `alpha`.  
  Например, если `alpha[0]` это `a`, то `key[0]` это буква, на которую `a` будет заменяться.

---

### Обработка входной строки и замена символов

- **`input`** — входная строка, приведённая к нижнему регистру. Это делает шифрование нечувствительным к регистру входа.

- Проход по каждому символу `input`:  
  - Если символ есть в `alpha`, находится его индекс `alpha.indexOf(ch)` и в выход добавляется символ `key` с тем же индексом.  
  - Если символ не является буквой латинского алфавита, он добавляется в выход без изменений. Это сохраняет пробелы, знаки препинания и цифры.

- Такой подход реализует моноалфавитную подстановку: одна и та же входная буква всегда заменяется на одну и ту же выходную букву.

---

### Пример работы

- Ключ `wednesday` нормализуется и даёт уникальные буквы `wednsay`.  
  Дополняя оставшимися буквами алфавита получаем `wednsaybcfghijklmopqrtuvxz`.

- Для буквы `h` индекс в `alpha` равен 7. В `key[7]` стоит `b`. Значит `h` → `b`.  
  Аналогично `e` → `s`, `l` → `h`, `o` → `k`. Слово `hello` шифруется в `bshhk`.

---

### Сложность и граничные случаи

- **Временная сложность** примерно \(O(n + 26)\) где \(n\) это длина входной строки. Построение ключа и обход алфавита фиксированы по 26 символам. Поиск индекса буквы через `indexOf` в текущей реализации делает замену \(O(26)\) на символ, но поскольку алфавит фиксирован, это константа. В сумме алгоритм линейный по длине входа.

- **Память** использует константное дополнительное пространство для `alpha`, `key` и множества `used`.

- **Граничные случаи**:  
  - Пустая строка возвращает пустую строку.  
  - Пустой или отсутствующий ключ приводит к тому, что `key` будет просто обычным алфавитом и шифрование станет тождественным.  
  - Символы вне `a–z` сохраняются без изменений.  
  - Регистр входа игнорируется, потому что всё приводится к нижнему регистру.

---

Если хочешь, могу показать альтернативы оптимизации поиска индекса, добавить обратное дешифрование по той же карте, или сделать версию, сохраняющую исходный регистр букв.
