/**
 * Вычисляет минимальное количество шагов для выравнивания яблок.
 * @param {number[]} apples - Массив с количеством яблок у каждого ребенка.
 * @returns {number} - Минимальное количество шагов или -1, если это невозможно.
 */
function minSteps(apples) {
  const n = apples.length;
  const sum = apples.reduce((acc, val) => acc + val, 0);

  // --- Проверка 1: Можно ли разделить яблоки поровну? ---
  // Если общая сумма не делится нацело на количество детей, это невозможно.
  if (sum % n !== 0) {
    return -1;
  }

  const target = sum / n; // Целевое количество яблок у каждого
  let excess = 0; // Общее количество "лишних" яблок, которые нужно передать

  // --- Проверка 2: Можно ли выполнить перераспределение шагами по 2 яблока? ---
  // Разница между яблоками у *каждого* ребенка и целью *должна* быть четной.
  for (let apple of apples) {
    const diff = apple - target;

    // Если разница нечетная, мы не сможем достичь цели,
    // передавая по 2 яблока.
    if (diff % 2 !== 0) {
      return -1;
    }

    // Считаем общее количество яблок, которое нужно будет передать.
    // Мы считаем только "положительные" разницы (детей, у которых избыток).
    if (diff > 0) {
      excess += diff;
    }
  }

  // Общее количество яблок, которое нужно переместить, — 'excess'.
  // Поскольку каждый шаг перемещает 2 яблока,
  // общее количество шагов будет 'excess / 2'.
  // Нам не нужна отдельная проверка excess % 2, так как 'excess'
  // является суммой четных чисел (diff), он *гарантированно* будет четным.
  return excess / 2;
}
module.exports = minSteps;