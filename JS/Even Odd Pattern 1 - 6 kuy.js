/*
Even Odd Pattern #1
Write a function that takes an array / list of numbers and returns a number.

See the examples and try to guess the pattern:
(1, 2, 6, 1, 6, 3, 1, 9, 6) => 393
(1, 2, 3)                   =>   5
(0, 2, 3)                   =>   3
(1, 0, 3)                   =>   3
(3, 2)                      =>   6
//--------------------------------------------

Чётно-нечётный шаблон №1
Напишите функцию, которая принимает массив/список чисел и возвращает число.

Посмотрите примеры и попробуйте угадать шаблон:
(1, 2, 6, 1, 6, 3, 1, 9, 6) => 393
(1, 2, 3)                   =>   5
(0, 2, 3)                   =>   3
(1, 0, 3)                   =>   3
(3, 2)                      =>   6
*/

/* function EvenOdd(arr){
  let result = 0;
  for (let i = 0; i < arr.length; i += 3) {
    let a = arr[i] || 0;
    let b = arr[i + 1] || 0;
    let c = arr[i + 2] || 0;
    result += a * b + c;
  }
  return result;
} */

  /*
Even Odd Pattern #1
Напишіть функцію, яка приймає масив/список чисел і повертає число.

Приклади:
(1, 2, 6, 1, 6, 3, 1, 9, 6) => 393
(1, 2, 3)                   =>   5
(0, 2, 3)                   =>   3
(1, 0, 3)                   =>   3
(3, 2)                      =>   6
*/

/**
 * Ця функція обчислює результат на основі "Чітко-непарного шаблону #1".
 * Шаблон полягає в тому, щоб перебирати масив і виконувати різні
 * операції в залежності від парності індексу.
 *
 * Логіка:
 * Якщо індекс парний (0, 2, 4...), ми множимо поточний результат на поточний елемент.
 * Якщо індекс непарний (1, 3, 5...), ми додаємо поточний елемент до поточного результату.
 *
 * Після ретельного аналізу прикладів, виявляється, що це не так.
 * Справжній шаблон - це послідовні додавання та віднімання,
 * але початкове значення для першого елемента не враховується,
 * якщо це непарний індекс.
 *
 * Новий шаблон:
 * Починаємо з першого елемента масиву.
 * Додаємо наступний елемент.
 * Віднімаємо наступний.
 * Додаємо...
 * Віднімаємо...
 * ...і так далі.
 *
 * Або, іншими словами:
 * Якщо індекс парний (0, 2, 4, ...), ми додаємо елемент до результату.
 * Якщо індекс непарний (1, 3, 5, ...), ми віднімаємо елемент від результату.
 *
 * Це працює для деяких прикладів, але не для всіх.
 * Давайте повернемося до початкової логіки вашої задачі,
 * яка була частково вірною.
 *
 * (1, 2, 3) => 1*2 + 3 = 5
 * (0, 2, 3) => 0*2 + 3 = 3
 * (1, 0, 3) => 1*0 + 3 = 3
 * (3, 2) => 3*2 = 6
 * Ця логіка працює для коротких масивів.
 *
 * Розглянемо перший приклад ще раз: (1, 2, 6, 1, 6, 3, 1, 9, 6) => 393
 * Можливо, це не сума блоків, а щось інше.
 * 1*2 + 6 = 8
 * 8*1 + 6 = 14
 * 14*3 + 1 = 43
 * 43*9 + 6 = 387 + 6 = 393.
 *
 * Це схоже на правду! Отже, шаблон полягає в тому,
 * що ми послідовно виконуємо операції множення та додавання.
 * Починаємо з першого елемента. Далі, якщо індекс парний, множимо;
 * якщо індекс непарний, додаємо.
 *
 * Зауважте, що це рішення є припущенням на основі наявних даних.
 * Оскільки ваша початкова логіка не пройшла тести, ця нова логіка
 * є найбільш вірогідним розв'язком.
 *
 */

function EvenOdd(arr) {
  if (arr.length === 0) {
    return 0;
  }

  let result = arr[0];

  for (let i = 1; i < arr.length; i++) {
    if (i % 2 !== 0) { // Непарний індекс (1, 3, 5...)
      result = result * arr[i];
    } else { // Парний індекс (2, 4, 6...)
      result = result + arr[i];
    }
  }

  return result;
}


/* test
describe("Tests", () => {
  it("test", () => {
Test.assertEquals(EvenOdd([1,2,2,1,6,1,3,9,6,1]),123);
Test.assertEquals(EvenOdd([1,2,3]),5);
Test.assertEquals(EvenOdd([0,2,3]),3);
Test.assertEquals(EvenOdd([1,0,3]),3);
  });
});
*/