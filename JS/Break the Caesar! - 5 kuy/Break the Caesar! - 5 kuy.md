<div class="markdown prose max-w-none mb-8" id="description"><p>The Caesar cipher is a notorious (and notoriously simple) algorithm for encrypting a message: each letter is shifted a certain constant number of places in the alphabet. For example, applying a shift of <code>5</code> to the string <code>"Hello, world!"</code> yields <code>"Mjqqt, btwqi!"</code>, which is jibberish.</p>
<p>In this kata, your task is to decrypt Caesar-encrypted messages using nothing but your wits, your computer, and a <code>set</code> of the 1000 (plus a few) most common words in English in <strong>lowercase</strong> (made available to you as a preloaded variable named <code>WORDS</code>, which you may use in your code as if you had defined it yourself).</p>
<h3 id="given-a-message-your-function-must-return-the-most-likely-shift-value-as-an-integer">Given a message, your function must return the most likely shift value as an integer.</h3>
<p>A few hints:</p>
<ul>
<li>Be wary of punctuation</li>
<li>Shift values may not be higher than 25</li>
</ul>
</div>

<br> <hr> <br>

<div class="markdown prose max-w-none mb-8" id="description"><p>Шифр Цезаря — це сумнозвісний (і, як відомо, простий) алгоритм шифрування повідомлення: кожна літера зміщується на певну постійну кількість позицій в алфавіті. Наприклад, застосування зсуву <code>5</code> до рядка <code>"Hello, world!"</code> дає <code>"Mjqqt, btwqi!"</code>, що є нісенітницею.</p>
<p>У цьому ката ваше завдання — розшифрувати повідомлення, зашифровані за методом Цезаря, використовуючи лише свою кмітливість, комп’ютер та <code>набір</code> з 1000 (плюс кілька) найпоширеніших англійських слів у <strong>нижньому регістрі</strong> (доступний вам як попередньо завантажена змінна з назвою <code>WORDS</code>, яку ви можете використовувати у своєму коді так, ніби ви самі її визначили).</p>
<h3 id="given-a-message-your-function-must-return-the-most-likely-shift-value-as-an-integer">Якщо дано повідомлення, ваша функція повинна повернути найімовірніше значення зсуву як ціле число.</h3>
<p>Кілька підказки:</p>
<ul>
<li>Будьте обережні з пунктуацією</li>
<li>Значення Shift не можуть бути вищими за 25</li>
</ul>
</div>

Алгоритм рішення
Очищення тексту: Використовуємо регулярний вираз, щоб витягнути з рядка лише слова (ігноруючи розділові знаки).
Цикл перебору: Проходимо циклом від 0 до 25. Це наш потенційний зсув $s$.
Дешифрування: Для кожного слова в реченні "відкочуємо" кожну літеру назад на $s$ позицій.Формула для дешифрування символу з індексом $i$ при зсуві $s$:
$$i_{new} = (i_{old} - s) \pmod{26}$$
Підрахунок: Перевіряємо, скільки отриманих дешифрованих слів міститься в наборі WORDS.
Результат: Повертаємо той зсув, який показав найкращий результат.

Чому це працює?
Ефективність: Оскільки ми робимо максимум $26 \times N$ операцій (де $N$ — кількість літер у тексті), алгоритм працює миттєво.
Регістр та пунктуація: st.toLowerCase().match(/[a-z]+/g) ідеально готує дані, залишаючи лише "чисті" слова в нижньому регістрі, що відповідає формату словника WORDS.
Математичний нюанс: В JavaScript оператор % повертає залишок, який може бути від'ємним. Додавання + 26 до від'ємного результату — це стандартний спосіб реалізації циклічного зсуву (модульної арифметики).
До речі, приклад з DAM? та зсувом 7 насправді перетворюється на WTF? ($D(3) - 7 = W(22)$). Схоже, автори кати мають почуття гумору!


Це — «серце» алгоритму. Тут ми виконуємо математичну маніпуляцію, щоб перетворити зашифровану літеру назад у зрозумілу. Оскільки комп'ютери не розуміють літер так, як ми, вони бачать їх як числа (коди ASCII/Unicode).

Давай розберемо цей блок по кроках.

---

### 1. Перетворення літери в число (0–25)

```javascript
let code = char.charCodeAt(0) - 97;

```

* **`charCodeAt(0)`**: Цей метод повертає числовий код символу. В таблиці Unicode малі англійські літери йдуть підряд: `a` — це **97**, `b` — **98**, і так далі до `z` — **122**.
* **`- 97`**: Ми віднімаємо 97, щоб "обнулити" алфавіт. Тепер `a` стає **0**, `b` — **1**, ..., а `z` — **25**.

> Це критично важливо для математики: працювати з діапазоном  набагато зручніше, ніж з .

### 2. Зсув та магія залишку

```javascript
let shiftedCode = (code - shift) % 26;

```

* Ми намагаємося "відкотити" літеру назад на значення `shift`.
* **`% 26` (Оператор залишку)**: Потрібен для того, щоб алфавіт був "циклічним". Хоча тут ми віднімаємо, цей оператор гарантує, що ми залишаємося в межах 26 літер.

### 3. Виправлення помилки JavaScript (Від'ємні числа)

```javascript
if (shiftedCode < 0) shiftedCode += 26;

```

Ось тут криється нюанс. В математиці  (тобто крок назад від "A" — це "Z").
Але в JavaScript результат виразу `-1 % 26` буде `-1`.

* **Приклад:** Якщо ми маємо літеру `a` (код 0) і зсув `1`, ми отримаємо `-1`.
* Додаючи `26`, ми перетворюємо `-1` на `25`, що відповідає літері `z`. Це замикає наше "коло" алфавіту.

### 4. Повернення до символу

```javascript
decryptedWord += String.fromCharCode(shiftedCode + 97);

```

Тепер ми робимо все навпаки:

* **`+ 97`**: Повертаємо наше число () до оригінальних кодів Unicode ().
* **`String.fromCharCode(...)`**: Перетворює число (наприклад, 97) назад у рядок (літеру "a").
* **`+=`**: Додаємо отриману літеру до нашого слова, що розшифровується.

---

### Наочний приклад:

Припустимо, слово — **"f"**, а зсув — **5**.

1. `f` має код 102. . Отже, `code = 5`.
2. `shiftedCode = 5 - 5 = 0`.
3. `0` не менше нуля, нічого не додаємо.
4. `0 + 97 = 97`.
5. `String.fromCharCode(97)` — це **"a"**.

Результат: **f  a**.

**Чи хочете ви, щоб я показав, як змінити цей код, щоб він підтримував також великі літери (A-Z)?**
