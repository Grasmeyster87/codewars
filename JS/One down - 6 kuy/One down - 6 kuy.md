<div class="markdown prose max-w-5xl mx-auto overflow-x-auto break-words" id="description"><p>A very passive-aggressive co-worker of yours was just fired. While he was gathering his things, he quickly inserted a bug into your system which renamed everything to what looks like jibberish. He left two notes on his desk, one reads: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" while the other reads: "Uif usjdl up uijt lbub jt tjnqmf kvtu sfqmbdf fwfsz mfuufs xjui uif mfuufs uibu dpnft cfgpsf ju".</p>
<p>Rather than spending hours trying to find the bug itself, you decide to try and decode it. </p>
<p>In case your language allows it and the input is not a string, your function must return "Input is not a string". Your function must be able to handle capital and lower case letters. You will not need to worry about punctuation.</p>
</div>

<br> <hr> <br>

<div class="markdown prose max-w-5xl mx-auto overflow-x-auto break-words" id="description"><p>Ваш очень пассивно-агрессивный коллега только что был уволен. Пока он собирал свои вещи, он быстро внедрил в вашу систему ошибку, которая переименовала все в нечто, похожее на бессмыслицу. Он оставил на своем столе две записки: одна гласит: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", а другая: "Uif usjdl up uijt lbub jt tjnqmf kvtu sfqmbdf fwfsz mfuufs xjui uif mfuufs uibu dpnft cfgpsf ju".</p>
<p>Вместо того чтобы тратить часы на поиски самой ошибки, вы решаете попытаться ее расшифровать. </p>
<p>Если ваш язык программирования это позволяет, и входные данные не являются строкой, ваша функция должна возвращать "Входные данные не являются строкой". Ваша функция должна уметь обрабатывать заглавные и строчные буквы. Вам не нужно беспокоиться о пунктуации.</p>
</div>

Чудово, що ви вивчаєте це! Не хвилюйтеся, шифрування у цій задачі — це варіація класичного **"Шифру Цезаря"** (зсув літер), але з однією хитрою особливістю.

Давайте розберемо це завдання "по кісточках".

### 1. Логіка шифру (Секрет у записці)

У задачі сказано, що колега залишив записку:

> `"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"`

Це **ключ** до розуміння. У стандартній таблиці символів (ASCII), якою користується комп'ютер, між великою `Z` і маленькою `a` знаходяться спеціальні символи (`[`, `\`, `]`, `^`, `_`, ```).

Але в цій задачі нас просять уявити, що **алфавіт — це одне довге, безперервне кільце**, де:

1. Після великої **Z** одразу йде маленька **a**.
2. Після маленької **z** знову йде велика **A** (замикаємо коло).

**Завдання:** "replace every letter with the letter that comes before it" (замінити кожну літеру на ту, що стоїть перед нею).

#### Схематично це виглядає так:

Уявіть цей рядок як лінійку:
`... -> Y -> Z -> a -> b -> ... -> y -> z -> A -> B -> ...`

Нам треба зробити крок **назад (-1)**:

* Якщо вхід **`C`**, крок назад -> **`B`**. (Просто)
* Якщо вхід **`b`**, крок назад -> **`a`**. (Просто)
* **Складний момент 1:** Якщо вхід **`a`**, крок назад -> **`Z`**. (Тут ми "перестрибуємо" регістр).
* **Складний момент 2:** Якщо вхід **`A`**, крок назад -> **`z`**. (Тут ми замикаємо кінець списку з початком).

---

### 2. Як це реалізувати в коді (ASCII коди)

Комп'ютер не розуміє літери як картинки, він розуміє їх як числа (ASCII коди):

* `A` = 65 ... `Z` = 90
* `a` = 97 ... `z` = 122

Нам потрібно обробити 3 сценарії:

1. **Звичайний зсув:** Для більшості літер (наприклад, `C` або `d`) ми просто віднімаємо 1 від їхнього коду.
* `C` (67) стає `B` (66).


2. **Граничний випадок `a` (97):**
* Якщо ми просто віднімемо 1, отримаємо код 96 (це символ ```). А нам треба **`Z`** (90).


3. **Граничний випадок `A` (65):**
* Якщо ми просто віднімемо 1, отримаємо код 64 (це символ `@`). А нам треба **`z`** (122).



---

### 3. Повний розбір роботи функції

Ось детальний опис кожного рядка правильного рішення:

```javascript
function oneDown(str) {
  // 1. ПЕРЕВІРКА ТИПУ
  // У JavaScript (і в цій задачі) вхідні дані можуть бути чим завгодно (число, об'єкт).
  // Якщо це не рядок, ми не можемо його розшифрувати.
  if (typeof str !== 'string') return 'Input is not a string';

  let res = ''; // Сюди ми будемо по літері збирати розшифрований текст

  // 2. ЦИКЛ
  // Ми проходимо по кожному символу вхідного рядка від початку до кінця.
  for (let i = 0; i < str.length; i++) {
    
    const ch = str[i];          // Поточний символ (наприклад, 'B')
    const code = ch.charCodeAt(0); // Його числовий код (наприклад, 66)

    // --- ЛОГІКА РОЗШИФРУВАННЯ ---

    // 3. ОБРОБКА 'A'
    // Якщо це 'A' (початок великих літер), попередньою має бути остання маленька 'z'
    if (code === 65) {
      res += 'z'; 
    }
    
    // 4. ОБРОБКА 'a'
    // Якщо це 'a' (початок малих літер), попередньою за умовою задачі є 'Z'
    else if (code === 97) {
      res += 'Z';
    }
    
    // 5. РЕШТА ВЕЛИКИХ ЛІТЕР (від B до Z)
    // Якщо код від 66 (B) до 90 (Z).
    // Ми просто віднімаємо 1, щоб отримати попередню літеру в алфавіті.
    else if (code > 65 && code <= 90) {
      res += String.fromCharCode(code - 1);
    }
    
    // 6. РЕШТА МАЛИХ ЛІТЕР (від b до z)
    // Якщо код від 98 (b) до 122 (z).
    // Так само віднімаємо 1.
    else if (code > 97 && code <= 122) {
      res += String.fromCharCode(code - 1);
    }
    
    // 7. НЕ ЛІТЕРИ
    // Пробіли, коми, крапки, цифри — їх ми не чіпаємо, просто додаємо як є.
    else {
      res += ch;
    }
  }

  // 8. ПОВЕРНЕННЯ РЕЗУЛЬТАТУ
  return res;
}

```

### Чому ваш попередній код не працював?

У вашому попередньому коді була така логіка для малих літер:

```javascript
// Ваша стара логіка
res += code === 97 ? 'z' : String.fromCharCode(code - 1);

```

Ви говорили: "Якщо це `a` (97), заміни на `z`". Це стандартна логіка (цикл `a-z`), але **не для цієї задачі**. Ця задача специфічна тим, що вона з'єднує великі та малі літери в один ланцюг. Тому `a` повинна перетворюватись на `Z`, а не на `z`.

### Підсумок для навчання

1. **Читайте умови про "алфавіт":** Часто задачі на шифрування змінюють стандартний порядок літер.
2. **ASCII таблиця:** Дуже корисно знати, що `A-Z` і `a-z` — це два окремі блоки чисел.
3. **Граничні умови (Edge Cases):** Завжди перевіряйте початок і кінець діапазону (що стоїть перед `A`? що стоїть перед `a`?). Саме там ховається більшість помилок.