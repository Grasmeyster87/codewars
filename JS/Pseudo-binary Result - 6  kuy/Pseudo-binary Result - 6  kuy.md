<div class="markdown prose max-w-none mb-8" id="description"><h2 id="definition">Definition</h2>
<p>For this task, we will use the term "pseudo-binary" number, defining it as a positive decimal number, which consists of only <code>1</code>s and/or <code>0</code>s. So, the number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>10110011</mn></mrow>10110011</math></span><span aria-hidden="true" class="katex-html"><span class="base"><span style="height:0.6444em;" class="strut"></span><span class="mord">10110011</span></span></span></span> might look like a regular binary number but it is <em>not</em>.</p>
<h2 id="task">Task</h2>
<p>For every <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi><mo>∈</mo><mi mathvariant="double-struck">N</mi></mrow>n \in \mathbb{N}</math></span><span aria-hidden="true" class="katex-html"><span class="base"><span style="height:0.5782em;vertical-align:-0.0391em;" class="strut"></span><span class="mord mathnormal">n</span><span style="margin-right:0.2778em;" class="mspace"></span><span class="mrel">∈</span><span style="margin-right:0.2778em;" class="mspace"></span></span><span class="base"><span style="height:0.6889em;" class="strut"></span><span class="mord mathbb">N</span></span></span></span>, there exist an infinite amount of positive integers <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>M</mi><mo>=</mo><mo stretchy="false">{</mo><msub><mi>m</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>m</mi><mn>3</mn></msub><mo separator="true">,</mo><mo>…</mo><mo stretchy="false">}</mo></mrow>M = \{m_1, m_2, m_3, \ldots \}</math></span><span aria-hidden="true" class="katex-html"><span class="base"><span style="height:0.6833em;" class="strut"></span><span style="margin-right:0.10903em;" class="mord mathnormal">M</span><span style="margin-right:0.2778em;" class="mspace"></span><span class="mrel">=</span><span style="margin-right:0.2778em;" class="mspace"></span></span><span class="base"><span style="height:1em;vertical-align:-0.25em;" class="strut"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.3011em;" class="vlist"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;" class="vlist"><span></span></span></span></span></span></span><span class="mpunct">,</span><span style="margin-right:0.1667em;" class="mspace"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.3011em;" class="vlist"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;" class="vlist"><span></span></span></span></span></span></span><span class="mpunct">,</span><span style="margin-right:0.1667em;" class="mspace"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.3011em;" class="vlist"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;" class="vlist"><span></span></span></span></span></span></span><span class="mpunct">,</span><span style="margin-right:0.1667em;" class="mspace"></span><span class="minner">…</span><span class="mclose">}</span></span></span></span>, such that, for any <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><msub><mi>m</mi><mi>i</mi></msub><mo>∈</mo><mi>M</mi></mrow>m_i \in M</math></span><span aria-hidden="true" class="katex-html"><span class="base"><span style="height:0.6891em;vertical-align:-0.15em;" class="strut"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.3117em;" class="vlist"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;" class="vlist"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;" class="mspace"></span><span class="mrel">∈</span><span style="margin-right:0.2778em;" class="mspace"></span></span><span class="base"><span style="height:0.6833em;" class="strut"></span><span style="margin-right:0.10903em;" class="mord mathnormal">M</span></span></span></span>, the number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi><mo>×</mo><msub><mi>m</mi><mi>i</mi></msub></mrow>n \times m_i</math></span><span aria-hidden="true" class="katex-html"><span class="base"><span style="height:0.6667em;vertical-align:-0.0833em;" class="strut"></span><span class="mord mathnormal">n</span><span style="margin-right:0.2222em;" class="mspace"></span><span class="mbin">×</span><span style="margin-right:0.2222em;" class="mspace"></span></span><span class="base"><span style="height:0.5806em;vertical-align:-0.15em;" class="strut"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span style="height:0.3117em;" class="vlist"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;" class="pstrut"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span style="height:0.15em;" class="vlist"><span></span></span></span></span></span></span></span></span></span> results in a pseudo-binary number. Your task is to find any such number <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>m</mi></mrow>m</math></span><span aria-hidden="true" class="katex-html"><span class="base"><span style="height:0.4306em;" class="strut"></span><span class="mord mathnormal">m</span></span></span></span> based on the input <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mi>n</mi></mrow>n</math></span><span aria-hidden="true" class="katex-html"><span class="base"><span style="height:0.4306em;" class="strut"></span><span class="mord mathnormal">n</span></span></span></span>.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python"><span class="cm-variable">pseudo_binary</span>(<span class="cm-number">2</span>)  <span class="cm-comment"># can return 5;          2 * 5  = 10</span>
<span class="cm-variable">pseudo_binary</span>(<span class="cm-number">3</span>)  <span class="cm-comment"># can return 37;         3 * 37 = 111</span>
<span class="cm-variable">pseudo_binary</span>(<span class="cm-number">10</span>) <span class="cm-comment"># can return 1;          10 * 1 = 10</span>
<span class="cm-variable">pseudo_binary</span>(<span class="cm-number">9</span>)  <span class="cm-comment"># can return 12 345 679; 9 * 12 345 679 = 111 111 111</span>
</code></pre>
<h2 id="random-tests">Random tests</h2>
<ul>
<li>100 small random tests (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>1</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>100</mn></mrow>1 \le n \le 100</math></span><span aria-hidden="true" class="katex-html"><span class="base"><span style="height:0.7804em;vertical-align:-0.136em;" class="strut"></span><span class="mord">1</span><span style="margin-right:0.2778em;" class="mspace"></span><span class="mrel">≤</span><span style="margin-right:0.2778em;" class="mspace"></span></span><span class="base"><span style="height:0.7719em;vertical-align:-0.136em;" class="strut"></span><span class="mord mathnormal">n</span><span style="margin-right:0.2778em;" class="mspace"></span><span class="mrel">≤</span><span style="margin-right:0.2778em;" class="mspace"></span></span><span class="base"><span style="height:0.6444em;" class="strut"></span><span class="mord">100</span></span></span></span>)</li>
<li>50 medium random tests (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>101</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>1000</mn></mrow>101 \le n \le 1000</math></span><span aria-hidden="true" class="katex-html"><span class="base"><span style="height:0.7804em;vertical-align:-0.136em;" class="strut"></span><span class="mord">101</span><span style="margin-right:0.2778em;" class="mspace"></span><span class="mrel">≤</span><span style="margin-right:0.2778em;" class="mspace"></span></span><span class="base"><span style="height:0.7719em;vertical-align:-0.136em;" class="strut"></span><span class="mord mathnormal">n</span><span style="margin-right:0.2778em;" class="mspace"></span><span class="mrel">≤</span><span style="margin-right:0.2778em;" class="mspace"></span></span><span class="base"><span style="height:0.6444em;" class="strut"></span><span class="mord">1000</span></span></span></span>)</li>
<li>20 large random tests (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><mrow><mn>1001</mn><mo>≤</mo><mi>n</mi><mo>≤</mo><mn>5000</mn></mrow>1001 \le n \le 5000</math></span><span aria-hidden="true" class="katex-html"><span class="base"><span style="height:0.7804em;vertical-align:-0.136em;" class="strut"></span><span class="mord">1001</span><span style="margin-right:0.2778em;" class="mspace"></span><span class="mrel">≤</span><span style="margin-right:0.2778em;" class="mspace"></span></span><span class="base"><span style="height:0.7719em;vertical-align:-0.136em;" class="strut"></span><span class="mord mathnormal">n</span><span style="margin-right:0.2778em;" class="mspace"></span><span class="mrel">≤</span><span style="margin-right:0.2778em;" class="mspace"></span></span><span class="base"><span style="height:0.6444em;" class="strut"></span><span class="mord">5000</span></span></span></span>)</li>
</ul>
<p>Good luck!</p>
</div>

Вот подробное объяснение задачи и оптимизированное решение. Ваш текущий код работает методом «грубой силы» (brute-force), что слишком медленно для больших чисел.

### Суть задания

Вам дано число . Нужно найти такое число , чтобы при умножении получилось число, состоящее **только из цифр 0 и 1** (так называемое «псевдобинарное» число).

**Пример:**
Если :

1. Умножаем на разные числа, пока результат не будет выглядеть как бинарный код.
2. .
3. состоит только из единиц.
4. Ответ (наше ) — это **37**.

### Почему ваш код медленный?

Ваш код перебирает множители и проверяет результат.
Для , ближайшее псевдобинарное число — .
Чтобы его найти, вашему циклу придется перебрать итераций. А для , близких к 5000, количество итераций может стать астрономическим, и код упадет по таймауту.

### Правильный алгоритм (BFS)

Вместо того чтобы перебирать множители (), нужно **генерировать псевдобинарные числа** () и проверять, делятся ли они на .

Мы используем **Поиск в ширину (BFS)** по остаткам от деления:

1. Начинаем с числа .
2. На каждом шаге мы можем приписать к числу либо `0`, либо `1`.

-   Из получаем и .
-   Из получаем и , и так далее.

3. Чтобы числа не росли бесконечно, мы запоминаем только **остаток от деления на **. Если мы пришли к остатку, который уже видели, этот путь тупиковый (он не даст нового результата быстрее).
4. Как только остаток становится равен , значит, мы нашли псевдобинарное число, которое делится на без остатка.

### Решение

Вот оптимизированный код. Он использует `BigInt`, так как числа могут быть очень длинными (до 5000 знаков).

```javascript
function pseudoBinary(n) {
    // Приводим n к BigInt, если оно еще не таковое (для безопасности)
    const bn = BigInt(n);

    // Очередь для BFS. Хранит объекты:
    // rem: текущий остаток от деления найденного псевдобинарного числа на n
    // val: само псевдобинарное число (P)
    const queue = [{ rem: 1n % bn, val: 1n }];

    // Сет для хранения посещенных остатков, чтобы избежать зацикливания
    const visited = new Set([1n % bn]);

    // Используем индекс вместо shift() для производительности
    let head = 0;

    while (head < queue.length) {
        const { rem, val } = queue[head++];

        // Если остаток 0, значит val делится на n нацело.
        // Наша задача вернуть m, то есть (val / n)
        if (rem === 0n) {
            return val / bn;
        }

        // Генерируем следующие два числа: дописываем '0' и дописываем '1'

        // Вариант 1: Дописываем 0 (это умножение на 10)
        const rem0 = (rem * 10n) % bn;
        if (!visited.has(rem0)) {
            visited.add(rem0);
            queue.push({ rem: rem0, val: val * 10n });
        }

        // Вариант 2: Дописываем 1 (это умножение на 10 и прибавление 1)
        const rem1 = (rem * 10n + 1n) % bn;
        if (!visited.has(rem1)) {
            visited.add(rem1);
            queue.push({ rem: rem1, val: val * 10n + 1n });
        }
    }
}

module.exports = pseudoBinary;
```

### Как это работает математически:

1. Пусть мы ищем псевдобинарное число .
2. Мы строим цифра за цифрой:
3. Мы ищем такое , что .
4. В худшем случае (согласно принципу Дирихле) длина числа не превысит цифр, поэтому алгоритм работает очень быстро даже для .

Хотите, я объясню подробнее, как работает логика с `visited` (остатками) и почему это гарантирует нахождение минимального числа?
