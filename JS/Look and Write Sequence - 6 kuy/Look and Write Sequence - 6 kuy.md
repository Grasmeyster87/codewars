You are tasked with a variant of the "look-and-write" sequence. The sequence is built iteratively according to the following rules. 
Start with the sequence "11". After looking at the current sequence, for each digit 0–9, check how many times it appears. 
For every digit that occurs at least once, append its count followed by the digit to the end of the sequence. 
The new sequence is formed by adding all these pairs in order to the current sequence.

Your task is to compute the length of the sequence after n looks on the sequence.

Input: n, the number of times you look at the sequence (0 ≤ n ≤ 7*10^5) for Javascript, for Python: (0 ≤ n ≤ 2*10^5)

Output: An integer representing the length of the sequence after n looks

Examples:

n = 1

Start with "11". Then, for the first look, it’s "11" + there are two 1s, so "21". Concatenating gives "1121", and the length is 4.

n = 3

Start with "11". Then, for the first look, it’s "11" + there are two 1s, so "21". 
Concatenating gives "1121". 
For the second look, there are three 1s and one 2, so concatenate "1121" + "31" + "12" → "11213112". For the last look, in "11213112" there are five 1s,
 two 2s, and one 3, so concatenate "11213112" + "51" + "22" + "13" → "11213112512213". The length is 14.

Вам предлагается вариант последовательности «посмотри и запиши». 
Последовательность строится итеративно по следующим правилам. 
Начните с последовательности «11». 
После просмотра текущей последовательности для каждой цифры от 0 до 9 проверьте, сколько раз она встречается. 
Для каждой цифры, которая встречается хотя бы один раз, добавьте её количество, 
а затем саму цифру в конец последовательности. Новая последовательность формируется путём добавления всех этих пар по порядку к текущей последовательности.

Ваша задача — вычислить длину последовательности после n просмотров.

Входные данные: n — количество просмотров последовательности (0 ≤ n ≤ 7*10^5) для Javascript, для Python: (0 ≤ n ≤ 2*10^5)

Выходные данные: Целое число, представляющее длину последовательности после n просмотров.

Примеры:

n = 1

Начните с «11». Тогда для первого варианта это «11» + две единицы, поэтому «21». Конкатенация даёт «1121», и длина равна 4.

n = 3

Начнем с «11». Тогда для первого варианта это «11» + две единицы, поэтому «21». Конкатенация даёт «1121». 
Во втором варианте три единицы и одна двойка, поэтому конкатенируем «1121» + «31» + «12» → «11213112». 
В последнем варианте в «11213112» пять единиц, две двойки и одна тройка, поэтому конкатенируем «11213112» + «51» + «22» + «13» → «11213112512213». Длина равна 14.

Ось ефективне рішення для завдання "Look and Write".

### Аналіз задачі

Головна проблема цього завдання — експоненціальне зростання довжини рядка. Якщо просто генерувати рядок (конкатенація), пам'ять та час виконання швидко вичерпаються, оскільки $N$ може сягати $700,000$.

Натомість нам не потрібен сам рядок, а лише його **довжина** та **кількість кожної цифри (0-9)**.
Ми можемо зберігати масив `counts` з 10 елементів, де індекс — це цифра, а значення — скільки разів вона зустрічається.

**Алгоритм ($O(N)$):**
1. Починаємо з "11". Це означає: довжина = 2, кількість одиниць = 2, інші нулі.
2. Для кожного кроку від 0 до $N-1$:
   - Створюємо тимчасовий буфер для змін (щоб оновлення не впливали на поточні розрахунки в межах одного кроку).
   - Проходимо по цифрах від 0 до 9.
   - Якщо цифра $d$ присутня в послідовності (її кількість $count > 0$):
     - Ми додаємо до послідовності пару: `{count}{d}`.
     - Це збільшує загальну довжину на `довжину числа count` + 1.
     - Оновлюємо лічильники для самої цифри $d$ та для всіх цифр, з яких складається число $count$.
   - Застосовуємо зміни до основного масиву лічильників.

Цей підхід працює дуже швидко, оскільки на кожній ітерації ми виконуємо фіксовану кількість операцій (максимум 10 цифр для перевірки).

Ось файл із рішенням та тестами:


http://googleusercontent.com/immersive_entry_chip/0

Суть завдання — це варіація математичної гри з генерації послідовності чисел. Це схоже на відому послідовність "Look-and-Say" (Подивись і скажи), але з двома важливими відмінностями:
1. Ми рахуємо **загальну кількість** кожної цифри у всьому рядку (а не групи однакових цифр підряд).
2. Ми **дописуємо** результат у кінець існуючого рядка (а не замінюємо його).

### Алгоритм простими словами:

1.  **Старт:** У вас є рядок `"11"`.
2.  **Погляд (Look):** Ви дивитесь на поточний рядок і рахуєте, скільки разів у ньому зустрічається кожна цифра (від 0 до 9).
3.  **Запис (Write):** Для кожної знайденої цифри ви формуєте пару: `[кількість][саме_число]`.
4.  **Оновлення:** Отримані пари дописуються в кінець рядка.
5.  **Повторення:** Ви повторюєте це `n` разів.
6.  **Результат:** Потрібно повернути **довжину** кінцевого рядка.

---

### Розбір прикладу (крок за кроком)

**Старт:** Рядок = `"11"`

**Крок 1 (n=1):**
* Дивимось на `"11"`.
* Рахуємо: одиниць (`1`) є **2** штуки.
* Формуємо добавку: `2` (кількість) + `1` (цифра) = `"21"`.
* Дописуємо: `"11"` + `"21"` = **`"1121"`**.
* *Довжина = 4.*

**Крок 2 (n=2):**
* Дивимось на поточний рядок `"1121"`.
* Рахуємо цифри:
    * Одиниць (`1`): 3 штуки. -> Добавка `"31"`
    * Двійок (`2`): 1 штука. -> Добавка `"12"`
* Дописуємо по порядку (спочатку для 1, потім для 2): `"1121"` + `"31"` + `"12"`.
* Новий рядок: **`"11213112"`**.
* *Довжина = 8.*

**Крок 3 (n=3):**
* Дивимось на `"11213112"`.
* Рахуємо:
    * Одиниць (`1`): 5 штук -> `"51"`
    * Двійок (`2`): 2 штуки -> `"22"`
    * Трійок (`3`): 1 штука -> `"13"`
* Дописуємо: `"11213112"` + `"51"` + `"22"` + `"13"`.
* Новий рядок: **`"11213112512213"`**.
* *Довжина = 14.*

---

### У чому складність для програмування?

Якщо `n` буде великим (наприклад, 700,000), рядок стане астрономічно довгим. Він не поміститься в оперативну пам'ять жодного комп'ютера.

**Рішення в коді (`solution.js`):**
Вам не потрібно зберігати сам рядок. Вам потрібно знати лише:
1.  **Поточну довжину** (`totalLength`).
2.  **Кількість кожної цифри** (`counts` масив з 10 елементів).

Код працює так: він "віртуально" додає нові цифри, просто збільшуючи лічильники в масиві `counts` і змінну `totalLength`, не створюючи гігантський текстовий рядок.