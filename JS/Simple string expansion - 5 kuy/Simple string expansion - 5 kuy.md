Consider the following expansion:

"3(ab)"     expands to "ababab"    -- because "ab" repeats 3 times
"2(a3(b))"  expands to "abbbabbb"  -- "a3(b)" expands to "abbb" and that repeats twice

Given a string, return the expansion of that string.

Rules:

    The input is guaranteed to be well-formed and balanced.
    Multipliers are single digits in the range 1–9, and are optional.
    Every multiplier is immediately followed by a parenthesised group.
    After a group is fully expanded, nothing appears beyond the final closing parenthesis.

Lowercase letters and digits are the only characters that appear.

Рассмотрим следующее разложение:

«3(ab)» раскрывается в «ababab», потому что «ab» повторяется 3 раза.
«2(a3(b))» раскрывается в «abbbabbb», а «a3(b)» раскрывается в «abbb», повторяющееся дважды.

Для заданной строки верните разложение этой строки.

Правила:

Входные данные гарантированно корректны и сбалансированы.
Множители — это однозначные числа в диапазоне от 1 до 9, и их указывать необязательно.
За каждым множителем сразу следует группа в скобках.
После полного разложения группы за последней закрывающей скобкой ничего не отображается.

Допускаются только строчные буквы и цифры.

Давай разберу это решение по шагам:

## Основная идея
Это рекурсивное решение, которое постепенно "раскрывает" скобки, начиная с самых внутренних.

## Как работает функция `solve(str)`:

### 1. **Проверка наличия скобок**
```javascript
while (str.includes('(')) {
```
Функция продолжает работать, пока в строке есть хотя бы одна открывающая скобка.

### 2. **Поиск и замена скобок**
```javascript
str = str.replace(regex, (match, mult, inner) => {
```
Здесь используется регулярное выражение `(\d*)\(([^()]*)\)`:
- `(\d*)` - захватывает множитель (цифры)
- `\(` - захватывает открывающую скобку
- `([^()]*)` - захватывает содержимое скобок (всё, кроме скобок)
- `\)` - захватывает закрывающую скобку

### 3. **Рекурсивное раскрытие**
```javascript
const expanded = solve(inner);
return expanded.repeat(parseInt(mult) || 1);
```

## Пример работы с `2(a3(b))`:

### Шаг 1: `2(a3(b))`
- Находит `2(a3(b))`
- `mult = "2"`, `inner = "a3(b)"`
- Рекурсивно вызывает `solve("a3(b)")`

### Шаг 2: `a3(b)`  
- Находит `3(b)`
- `mult = "3"`, `inner = "b"`
- `solve("b")` возвращает `"b"`
- `"b".repeat(3)` = `"bbb"`
- Возвращаем `"a" + "bbb" = "abb"`

### Шаг 3: Возвращаемся к `2(a3(b))`
- `solve("a3(b)")` вернул `"abb"`
- `"abb".repeat(2)` = `"abbbabbb"`

## Детальный разбор:

### Для `3(b(2(c)))`:
1. `3(b(2(c)))` → `3(bcc)` → `bccbccbcc`

### Для `k(a3(b(a2(c))))`:
1. `k(a3(b(a2(c))))` → `k(a3(bacc))` → `k(a3baccbacc)` → `k(abaccbaccbacc)`

## Ключевые особенности:

1. **Рекурсивность**: Каждая внутренняя группа обрабатывается рекурсивно
2. **Правильная обработка множителей**: Если множитель отсутствует, он равен 1
3. **Последовательность**: Сначала обрабатываются внутренние скобки, потом внешние

## Как работает регулярное выражение:
- `(\d*)\(([^()]*)\)` - находит: 
  - `(\d*)` - любые цифры (может быть пустым)
  - `\(` - открывающая скобка
  - `([^()]*)` - любые символы, кроме скобок
  - `\)` - закрывающая скобка

Это позволяет корректно обрабатывать случаи без множителя: `(abc)` → `abc`

Давай разберу эту часть подробно:

## Что делает `str.replace(regex, callback)`:

### 1. **Поиск совпадений**
Функция `replace` ищет все вхождения регулярного выражения в строке и вызывает callback для каждого совпадения.

### 2. **Параметры callback функции**
```javascript
(match, mult, inner) => {
    // match - всё совпадение целиком
    // mult - первая группа захвата (\d*) - множитель
    // inner - вторая группа захвата ([^()]*) - содержимое скобок
}
```

## Пример работы с `2(a3(b))`:

### Первый вызов (когда `str = "2(a3(b))"`):
- **match** = `"2(a3(b))"` (всё совпадение)
- **mult** = `"2"` (множитель)
- **inner** = `"a3(b)"` (содержимое скобок)

### Внутри callback:
```javascript
const expanded = solve("a3(b)");  // Рекурсивный вызов
return expanded.repeat(parseInt("2") || 1);  // Умножаем на 2
```

## Давай посмотрим, как работает `solve("a3(b)")`:

### Второй вызов (когда `str = "a3(b)"`):
- **match** = `"3(b)"` (всё совпадение)
- **mult** = `"3"` (множитель)
- **inner** = `"b"` (содержимое скобок)

### Внутри callback:
```javascript
const expanded = solve("b");  // Рекурсивный вызов
return expanded.repeat(parseInt("3") || 1);  // Умножаем на 3
```

### Третий вызов (когда `str = "b"`):
- **match** = `null` (нет скобок)
- Возвращается `"b"` как есть

## Возвращаемся назад:

### Второй вызов возвращает:
- `expanded = "b"`
- `"b".repeat(3)` = `"bbb"`
- Возвращаем `"a" + "bbb" = "abb"`

### Первый вызов возвращает:
- `expanded = "abb"`
- `"abb".repeat(2)` = `"abbbabbb"`

## Схема выполнения:

```
solve("2(a3(b))")
├── solve("a3(b)") 
│   ├── solve("b") → "b"
│   └── "b".repeat(3) → "bbb"
│   └── "a" + "bbb" → "abb"
└── "abb".repeat(2) → "abbbabbb"
```

## Ключевые моменты:

1. **Рекурсия**: Каждый вызов `solve()` обрабатывает свою часть строки
2. **Замена**: `replace` заменяет найденную подстроку на результат
3. **Последовательность**: Обрабатываются скобки по уровням вложенности
4. **Множитель**: Если множитель пустой, используется `1` (поэтому `|| 1`)