// Карта для мемоизации (кеширования) результатов подзадач. 
// Это необходимо, так как размеры области могут быть очень большими (BigInt),
// и рекурсия может многократно вызывать одну и ту же подзадачу.
const memo = new Map();

/**
 * Вспомогательная функция для нахождения наибольшей степени двойки (S), 
 * которая меньше или равна заданному числу (n).
 * @param {bigint} n - Размер стороны.
 * @returns {bigint} - Наибольшая степень 2, S <= n.
 */
const getLargestPowerOfTwo = (n) => {
    // Итеративный подход безопасен и эффективен, так как количество итераций равно log2(n).
    let s = 1n;
    let s_next = 2n;
    while (s_next <= n) {
        s = s_next;
        s_next = s_next << 1n; // Сдвиг влево эквивалентен умножению на 2
    }
    return s;
};

/**
 * Вычисляет минимальное количество квадратных плиток (размером 2^k x 2^k), 
 * необходимое для покрытия прямоугольной области.
 * * Логика основана на жадном рекурсивном разложении:
 * 1. Находим наибольшую возможную квадратную плитку S x S, где S - степень 2, S <= min(W, H).
 * 2. Используем N_W = floor(W / S) плиток S x S для покрытия полосы W x S.
 * 3. Рекурсивно решаем две оставшиеся области:
 * a) Полоса оставшейся ширины: (W % S) x H
 * б) Полоса оставшейся высоты: (N_W * S) x (H - S)
 * * @param {bigint} width - Ширина области.
 * @param {bigint} height - Высота области.
 * @returns {bigint} - Минимальное количество плиток.
 */
function numTiles(width, height) {
    // Базовый случай: если одна из сторон равна 0 или меньше, плитки не нужны.
    if (width <= 0n || height <= 0n) return 0n;

    let W = width;
    let H = height;
    
    // Упорядочивание: гарантируем W >= H для согласованного ключа кеширования и логики
    if (W < H) {
        [W, H] = [H, W];
    }
    
    // Проверка мемоизации (кеширования)
    const key = `${W.toString()}_${H.toString()}`;
    if (memo.has(key)) {
        return memo.get(key);
    }
    
    // Шаг 1: Находим наибольшую степень 2 (S), S <= H.
    const S = getLargestPowerOfTwo(H);
    
    // Шаг 2: Количество плиток S x S, которые помещаются по ширине W.
    // N_W = W / S (целочисленное деление для BigInt)
    const N_W = W / S;
    
    // В текущем шаге мы используем N_W плиток S x S для покрытия полосы N_W*S x S.
    let totalTiles = N_W;
    
    // Шаг 3: Рекурсия для оставшихся двух областей.
    
    // Область 1 (Остаток по ширине): (W % S) x H
    // Это полоса, которая не покрылась плитками S x S из-за остатка по ширине.
    const W_rem = W % S;
    const tiles1 = numTiles(W_rem, H);
    
    // Область 2 (Остаток по высоте): (N_W * S) x (H - S)
    // Это оставшаяся часть высоты H над уже покрытой полосой N_W*S x S.
    const W_fixed = N_W * S;
    const H_rem = H - S; // H - S всегда будет > 0, если H > 0, так как S <= H
    const tiles2 = numTiles(W_fixed, H_rem);
    
    totalTiles = totalTiles + tiles1 + tiles2;
    
    // Сохранение результата и возврат
    memo.set(key, totalTiles);
    return totalTiles;
}

module.exports = numTiles;